import { NativeScriptModule } from '@nativescript/angular';
import { TestBed } from '@angular/core/testing';
import { platformBrowserDynamicTesting } from '@angular/platform-browser-dynamic/testing';
// import { NS_COMPILER_PROVIDERS } from "../../platform";
import { NativeScriptTestingModule } from './nativescript-testing.module';
import { testingRootView } from './test-root-view';
/**
 * Declared test contexts. When the suite is done this map should be empty if all lifecycle
 * calls have happened as expected.
 * @private
 */
const activeTestFixtures = [];
/**
 * Return a promise that resolves after (durationMs) milliseconds
 */
export function promiseWait(durationMs) {
    return () => new Promise((resolve) => setTimeout(() => resolve(), durationMs));
}
/**
 * Perform basic TestBed environment initialization. Call this once in the main entry point to your tests.
 * @deprecated
 */
export function nsTestBedInit() {
    TestBed.initTestEnvironment(NativeScriptTestingModule, platformBrowserDynamicTesting() // NS_COMPILER_PROVIDERS)
    );
}
/**
 * Helper for configuring a TestBed instance for rendering components for test. Ideally this
 * would not be needed, and in truth it's just a wrapper to eliminate some boilerplate. It
 * exists because when you need to specify `entryComponents` for a test the setup becomes quite
 * a bit more complex than if you're just doing a basic component test.
 *
 * More about entryComponents complexity: https://github.com/angular/angular/issues/12079
 *
 * Use:
 * ```
 *   beforeEach(nsTestBedBeforeEach([MyComponent,MyFailComponent]));
 * ```
 *
 * **NOTE*** Remember to pair with {@see nsTestBedAfterEach}
 *
 * @deprecated
 * @param components Any components that you will create during the test
 * @param providers Any services your tests depend on
 * @param imports Any module imports your tests depend on
 * @param entryComponents Any entry components that your tests depend on
 */
export function nsTestBedBeforeEach(components, providers = [], imports = [], entryComponents = []) {
    return (done) => {
        activeTestFixtures.push([]);
        // If there are no entry components we can take the simple path.
        if (entryComponents.length === 0) {
            TestBed.configureTestingModule({
                declarations: [...components],
                providers: [...providers],
                imports: [NativeScriptModule, ...imports],
            });
        }
        else {
            // If there are entry components, we have to reset the testing platform.
            //
            // There's got to be a better way... (o_O)
            // TestBed.resetTestEnvironment();
            // @NgModule({
            //     declarations: entryComponents,
            //     exports: entryComponents,
            //     entryComponents: entryComponents
            // })
            // class EntryComponentsTestModule {
            // }
            // TestBed.initTestEnvironment(
            //     EntryComponentsTestModule,
            //     platformBrowserDynamicTesting(NS_COMPILER_PROVIDERS)
            // );
            // TestBed.configureTestingModule({
            //     declarations: components,
            //     imports: [
            //         NativeScriptModule, NativeScriptTestingModule, CommonModule,
            //         ...imports
            //     ],
            //     providers: [...providers, ...NATIVESCRIPT_TESTING_PROVIDERS],
            // });
        }
        TestBed.compileComponents()
            .then(() => done())
            .catch((e) => {
            console.log(`Failed to instantiate test component with error: ${e}`);
            console.log(e.stack);
            done();
        });
    };
}
/**
 * Helper for a basic component TestBed clean up.
 * @param resetEnv When true the testing environment will be reset
 * @param resetFn When resetting the environment, use this init function
 * @deprecated
 */
export function nsTestBedAfterEach(resetEnv = true, resetFn = nsTestBedInit) {
    return () => {
        if (activeTestFixtures.length === 0) {
            throw new Error(`There are no more declared fixtures.` + `Did you call "nsTestBedBeforeEach" and "nsTestBedAfterEach" an equal number of times?`);
        }
        const root = testingRootView();
        const fixtures = activeTestFixtures.pop();
        fixtures.forEach((fixture) => {
            const fixtureView = fixture.nativeElement;
            if (fixtureView.parent === root) {
                root.removeChild(fixtureView);
            }
            fixture.destroy();
        });
        TestBed.resetTestingModule();
        if (resetEnv) {
            TestBed.resetTestEnvironment();
            resetFn();
        }
    };
}
/**
 * Render a component using the TestBed helper, and return a promise that resolves when the
 * ComponentFixture is fully initialized.
 * @deprecated
 */
export function nsTestBedRender(componentType) {
    const fixture = TestBed.createComponent(componentType);
    fixture.detectChanges();
    return (fixture
        .whenRenderingDone()
        // TODO(jd): it seems that the whenStable and whenRenderingDone utilities of ComponentFixture
        //           do not work as expected. I looked at how to fix it and it's not clear how to provide
        //           a {N} specific subclass, because ComponentFixture is newed directly rather than injected
        // What to do about it? Maybe fakeAsync can help? For now just setTimeout for 100ms (x_X)
        .then(promiseWait(100))
        .then(() => {
        const list = activeTestFixtures[activeTestFixtures.length - 1];
        if (!list) {
            console.warn('nsTestBedRender called without nsTestBedBeforeEach/nsTestBedAfter each. ' + "You are responsible for calling 'fixture.destroy()' when your test is done " + 'in order to clean up the components that are created.');
        }
        else {
            list.push(fixture);
        }
        return fixture;
    }));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2FuZ3VsYXIvdGVzdGluZy9zcmMvbGliL3V0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFHM0QsT0FBTyxFQUFvQixPQUFPLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUVsRSxPQUFPLEVBQUUsNkJBQTZCLEVBQUUsTUFBTSwyQ0FBMkMsQ0FBQztBQUMxRiwwREFBMEQ7QUFDMUQsT0FBTyxFQUFrQyx5QkFBeUIsRUFBRSxNQUFNLCtCQUErQixDQUFDO0FBQzFHLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUVuRDs7OztHQUlHO0FBQ0gsTUFBTSxrQkFBa0IsR0FBOEIsRUFBRSxDQUFDO0FBRXpEOztHQUVHO0FBQ0gsTUFBTSxVQUFVLFdBQVcsQ0FBQyxVQUFrQjtJQUM1QyxPQUFPLEdBQUcsRUFBRSxDQUFDLElBQUksT0FBTyxDQUFPLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsT0FBTyxFQUFFLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQztBQUN2RixDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLGFBQWE7SUFDM0IsT0FBTyxDQUFDLG1CQUFtQixDQUN6Qix5QkFBeUIsRUFDekIsNkJBQTZCLEVBQUUsQ0FBQyx5QkFBeUI7S0FDMUQsQ0FBQztBQUNKLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FvQkc7QUFDSCxNQUFNLFVBQVUsbUJBQW1CLENBQUMsVUFBaUIsRUFBRSxZQUFtQixFQUFFLEVBQUUsVUFBaUIsRUFBRSxFQUFFLGtCQUF5QixFQUFFO0lBQzVILE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFBRTtRQUNkLGtCQUFrQixDQUFDLElBQUksQ0FBQyxFQUFFLENB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R0FBRyxrQkFBa0IsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDL0QsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ1YsT0FBTyxDQUFDLElBQUksQ0FBQywwRUFBMEUsR0FBRyw2RUFBNkUsR0FBRyx1REFBdUQsQ0FBQyxDQUFDO1FBQ3JPLENBQUM7YUFBTSxDQUFDO1lBQ04sSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNyQixDQUFDO1FBQ0QsT0FBTyxPQUFPLENBQUM7SUFDakIsQ0FBQyxDQUFDLENBQ0wsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOYXRpdmVTY3JpcHRNb2R1bGUgfSBmcm9tICdAbmF0aXZlc2NyaXB0L2FuZ3VsYXInO1xuaW1wb3J0IHsgVmlldywgRnJhbWUsIExheW91dEJhc2UsIEdyaWRMYXlvdXQgfSBmcm9tICdAbmF0aXZlc2NyaXB0L2NvcmUnO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbXBvbmVudEZpeHR1cmUsIFRlc3RCZWQgfSBmcm9tICdAYW5ndWxhci9jb3JlL3Rlc3RpbmcnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IHBsYXRmb3JtQnJvd3NlckR5bmFtaWNUZXN0aW5nIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljL3Rlc3RpbmcnO1xuLy8gaW1wb3J0IHsgTlNfQ09NUElMRVJfUFJPVklERVJTIH0gZnJvbSBcIi4uLy4uL3BsYXRmb3JtXCI7XG5pbXBvcnQgeyBOQVRJVkVTQ1JJUFRfVEVTVElOR19QUk9WSURFUlMsIE5hdGl2ZVNjcmlwdFRlc3RpbmdNb2R1bGUgfSBmcm9tICcuL25hdGl2ZXNjcmlwdC10ZXN0aW5nLm1vZHVsZSc7XG5pbXBvcnQgeyB0ZXN0aW5nUm9vdFZpZXcgfSBmcm9tICcuL3Rlc3Qtcm9vdC12aWV3JztcblxuLyoqXG4gKiBEZWNsYXJlZCB0ZXN0IGNvbnRleHRzLiBXaGVuIHRoZSBzdWl0ZSBpcyBkb25lIHRoaXMgbWFwIHNob3VsZCBiZSBlbXB0eSBpZiBhbGwgbGlmZWN5Y2xlXG4gKiBjYWxscyBoYXZlIGhhcHBlbmVkIGFzIGV4cGVjdGVkLlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgYWN0aXZlVGVzdEZpeHR1cmVzOiBDb21wb25lbnRGaXh0dXJlPGFueT5bXVtdID0gW107XG5cbi8qKlxuICogUmV0dXJuIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIChkdXJhdGlvbk1zKSBtaWxsaXNlY29uZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb21pc2VXYWl0KGR1cmF0aW9uTXM6IG51bWJlcikge1xuICByZXR1cm4gKCkgPT4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZSgpLCBkdXJhdGlvbk1zKSk7XG59XG5cbi8qKlxuICogUGVyZm9ybSBiYXNpYyBUZXN0QmVkIGVudmlyb25tZW50IGluaXRpYWxpemF0aW9uLiBDYWxsIHRoaXMgb25jZSBpbiB0aGUgbWFpbiBlbnRyeSBwb2ludCB0byB5b3VyIHRlc3RzLlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5zVGVzdEJlZEluaXQoKSB7XG4gIFRlc3RCZWQuaW5pdFRlc3RFbnZpcm9ubWVudChcbiAgICBOYXRpdmVTY3JpcHRUZXN0aW5nTW9kdWxlLFxuICAgIHBsYXRmb3JtQnJvd3NlckR5bmFtaWNUZXN0aW5nKCkgLy8gTlNfQ09NUElMRVJfUFJPVklERVJTKVxuICApO1xufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgY29uZmlndXJpbmcgYSBUZXN0QmVkIGluc3RhbmNlIGZvciByZW5kZXJpbmcgY29tcG9uZW50cyBmb3IgdGVzdC4gSWRlYWxseSB0aGlzXG4gKiB3b3VsZCBub3QgYmUgbmVlZGVkLCBhbmQgaW4gdHJ1dGggaXQncyBqdXN0IGEgd3JhcHBlciB0byBlbGltaW5hdGUgc29tZSBib2lsZXJwbGF0ZS4gSXRcbiAqIGV4aXN0cyBiZWNhdXNlIHdoZW4geW91IG5lZWQgdG8gc3BlY2lmeSBgZW50cnlDb21wb25lbnRzYCBmb3IgYSB0ZXN0IHRoZSBzZXR1cCBiZWNvbWVzIHF1aXRlXG4gKiBhIGJpdCBtb3JlIGNvbXBsZXggdGhhbiBpZiB5b3UncmUganVzdCBkb2luZyBhIGJhc2ljIGNvbXBvbmVudCB0ZXN0LlxuICpcbiAqIE1vcmUgYWJvdXQgZW50cnlDb21wb25lbnRzIGNvbXBsZXhpdHk6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzEyMDc5XG4gKlxuICogVXNlOlxuICogYGBgXG4gKiAgIGJlZm9yZUVhY2gobnNUZXN0QmVkQmVmb3JlRWFjaChbTXlDb21wb25lbnQsTXlGYWlsQ29tcG9uZW50XSkpO1xuICogYGBgXG4gKlxuICogKipOT1RFKioqIFJlbWVtYmVyIHRvIHBhaXIgd2l0aCB7QHNlZSBuc1Rlc3RCZWRBZnRlckVhY2h9XG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSBjb21wb25lbnRzIEFueSBjb21wb25lbnRzIHRoYXQgeW91IHdpbGwgY3JlYXRlIGR1cmluZyB0aGUgdGVzdFxuICogQHBhcmFtIHByb3ZpZGVycyBBbnkgc2VydmljZXMgeW91ciB0ZXN0cyBkZXBlbmQgb25cbiAqIEBwYXJhbSBpbXBvcnRzIEFueSBtb2R1bGUgaW1wb3J0cyB5b3VyIHRlc3RzIGRlcGVuZCBvblxuICogQHBhcmFtIGVudHJ5Q29tcG9uZW50cyBBbnkgZW50cnkgY29tcG9uZW50cyB0aGF0IHlvdXIgdGVzdHMgZGVwZW5kIG9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuc1Rlc3RCZWRCZWZvcmVFYWNoKGNvbXBvbmVudHM6IGFueVtdLCBwcm92aWRlcnM6IGFueVtdID0gW10sIGltcG9ydHM6IGFueVtdID0gW10sIGVudHJ5Q29tcG9uZW50czogYW55W10gPSBbXSkge1xuICByZXR1cm4gKGRvbmUpID0+IHtcbiAgICBhY3RpdmVUZXN0Rml4dHVyZXMucHVzaChbXSk7XG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIGVudHJ5IGNvbXBvbmVudHMgd2UgY2FuIHRha2UgdGhlIHNpbXBsZSBwYXRoLlxuICAgIGlmIChlbnRyeUNvbXBvbmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBUZXN0QmVkLmNvbmZpZ3VyZVRlc3RpbmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IFsuLi5jb21wb25lbnRzXSxcbiAgICAgICAgcHJvdmlkZXJzOiBbLi4ucHJvdmlkZXJzXSxcbiAgICAgICAgaW1wb3J0czogW05hdGl2ZVNjcmlwdE1vZHVsZSwgLi4uaW1wb3J0c10sXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIGVudHJ5IGNvbXBvbmVudHMsIHdlIGhhdmUgdG8gcmVzZXQgdGhlIHRlc3RpbmcgcGxhdGZvcm0uXG4gICAgICAvL1xuICAgICAgLy8gVGhlcmUncyBnb3QgdG8gYmUgYSBiZXR0ZXIgd2F5Li4uIChvX08pXG4gICAgICAvLyBUZXN0QmVkLnJlc2V0VGVzdEVudmlyb25tZW50KCk7XG4gICAgICAvLyBATmdNb2R1bGUoe1xuICAgICAgLy8gICAgIGRlY2xhcmF0aW9uczogZW50cnlDb21wb25lbnRzLFxuICAgICAgLy8gICAgIGV4cG9ydHM6IGVudHJ5Q29tcG9uZW50cyxcbiAgICAgIC8vICAgICBlbnRyeUNvbXBvbmVudHM6IGVudHJ5Q29tcG9uZW50c1xuICAgICAgLy8gfSlcbiAgICAgIC8vIGNsYXNzIEVudHJ5Q29tcG9uZW50c1Rlc3RNb2R1bGUge1xuICAgICAgLy8gfVxuICAgICAgLy8gVGVzdEJlZC5pbml0VGVzdEVudmlyb25tZW50KFxuICAgICAgLy8gICAgIEVudHJ5Q29tcG9uZW50c1Rlc3RNb2R1bGUsXG4gICAgICAvLyAgICAgcGxhdGZvcm1Ccm93c2VyRHluYW1pY1Rlc3RpbmcoTlNfQ09NUElMRVJfUFJPVklERVJTKVxuICAgICAgLy8gKTtcbiAgICAgIC8vIFRlc3RCZWQuY29uZmlndXJlVGVzdGluZ01vZHVsZSh7XG4gICAgICAvLyAgICAgZGVjbGFyYXRpb25zOiBjb21wb25lbnRzLFxuICAgICAgLy8gICAgIGltcG9ydHM6IFtcbiAgICAgIC8vICAgICAgICAgTmF0aXZlU2NyaXB0TW9kdWxlLCBOYXRpdmVTY3JpcHRUZXN0aW5nTW9kdWxlLCBDb21tb25Nb2R1bGUsXG4gICAgICAvLyAgICAgICAgIC4uLmltcG9ydHNcbiAgICAgIC8vICAgICBdLFxuICAgICAgLy8gICAgIHByb3ZpZGVyczogWy4uLnByb3ZpZGVycywgLi4uTkFUSVZFU0NSSVBUX1RFU1RJTkdfUFJPVklERVJTXSxcbiAgICAgIC8vIH0pO1xuICAgIH1cbiAgICBUZXN0QmVkLmNvbXBpbGVDb21wb25lbnRzKClcbiAgICAgIC50aGVuKCgpID0+IGRvbmUoKSlcbiAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhgRmFpbGVkIHRvIGluc3RhbnRpYXRlIHRlc3QgY29tcG9uZW50IHdpdGggZXJyb3I6ICR7ZX1gKTtcbiAgICAgICAgY29uc29sZS5sb2coZS5zdGFjayk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgYSBiYXNpYyBjb21wb25lbnQgVGVzdEJlZCBjbGVhbiB1cC5cbiAqIEBwYXJhbSByZXNldEVudiBXaGVuIHRydWUgdGhlIHRlc3RpbmcgZW52aXJvbm1lbnQgd2lsbCBiZSByZXNldFxuICogQHBhcmFtIHJlc2V0Rm4gV2hlbiByZXNldHRpbmcgdGhlIGVudmlyb25tZW50LCB1c2UgdGhpcyBpbml0IGZ1bmN0aW9uXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gbnNUZXN0QmVkQWZ0ZXJFYWNoKHJlc2V0RW52ID0gdHJ1ZSwgcmVzZXRGbiA9IG5zVGVzdEJlZEluaXQpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBpZiAoYWN0aXZlVGVzdEZpeHR1cmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBhcmUgbm8gbW9yZSBkZWNsYXJlZCBmaXh0dXJlcy5gICsgYERpZCB5b3UgY2FsbCBcIm5zVGVzdEJlZEJlZm9yZUVhY2hcIiBhbmQgXCJuc1Rlc3RCZWRBZnRlckVhY2hcIiBhbiBlcXVhbCBudW1iZXIgb2YgdGltZXM/YCk7XG4gICAgfVxuICAgIGNvbnN0IHJvb3QgPSB0ZXN0aW5nUm9vdFZpZXcoKSBhcyBMYXlvdXRCYXNlO1xuICAgIGNvbnN0IGZpeHR1cmVzID0gYWN0aXZlVGVzdEZpeHR1cmVzLnBvcCgpO1xuICAgIGZpeHR1cmVzLmZvckVhY2goKGZpeHR1cmUpID0+IHtcbiAgICAgIGNvbnN0IGZpeHR1cmVWaWV3ID0gPFZpZXc+Zml4dHVyZS5uYXRpdmVFbGVtZW50O1xuICAgICAgaWYgKGZpeHR1cmVWaWV3LnBhcmVudCA9PT0gcm9vdCkge1xuICAgICAgICByb290LnJlbW92ZUNoaWxkKGZpeHR1cmVWaWV3KTtcbiAgICAgIH1cbiAgICAgIGZpeHR1cmUuZGVzdHJveSgpO1xuICAgIH0pO1xuICAgIFRlc3RCZWQucmVzZXRUZXN0aW5nTW9kdWxlKCk7XG4gICAgaWYgKHJlc2V0RW52KSB7XG4gICAgICBUZXN0QmVkLnJlc2V0VGVzdEVudmlyb25tZW50KCk7XG4gICAgICByZXNldEZuKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFJlbmRlciBhIGNvbXBvbmVudCB1c2luZyB0aGUgVGVzdEJlZCBoZWxwZXIsIGFuZCByZXR1cm4gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGVcbiAqIENvbXBvbmVudEZpeHR1cmUgaXMgZnVsbHkgaW5pdGlhbGl6ZWQuXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gbnNUZXN0QmVkUmVuZGVyPFQ+KGNvbXBvbmVudFR5cGU6IFR5cGU8VD4pOiBQcm9taXNlPENvbXBvbmVudEZpeHR1cmU8VD4+IHtcbiAgY29uc3QgZml4dHVyZSA9IFRlc3RCZWQuY3JlYXRlQ29tcG9uZW50KGNvbXBvbmVudFR5cGUpO1xuICBmaXh0dXJlLmRldGVjdENoYW5nZXMoKTtcbiAgcmV0dXJuIChcbiAgICBmaXh0dXJlXG4gICAgICAud2hlblJlbmRlcmluZ0RvbmUoKVxuICAgICAgLy8gVE9ETyhqZCk6IGl0IHNlZW1zIHRoYXQgdGhlIHdoZW5TdGFibGUgYW5kIHdoZW5SZW5kZXJpbmdEb25lIHV0aWxpdGllcyBvZiBDb21wb25lbnRGaXh0dXJlXG4gICAgICAvLyAgICAgICAgICAgZG8gbm90IHdvcmsgYXMgZXhwZWN0ZWQuIEkgbG9va2VkIGF0IGhvdyB0byBmaXggaXQgYW5kIGl0J3Mgbm90IGNsZWFyIGhvdyB0byBwcm92aWRlXG4gICAgICAvLyAgICAgICAgICAgYSB7Tn0gc3BlY2lmaWMgc3ViY2xhc3MsIGJlY2F1c2UgQ29tcG9uZW50Rml4dHVyZSBpcyBuZXdlZCBkaXJlY3RseSByYXRoZXIgdGhhbiBpbmplY3RlZFxuICAgICAgLy8gV2hhdCB0byBkbyBhYm91dCBpdD8gTWF5YmUgZmFrZUFzeW5jIGNhbiBoZWxwPyBGb3Igbm93IGp1c3Qgc2V0VGltZW91dCBmb3IgMTAwbXMgKHhfWClcbiAgICAgIC50aGVuKHByb21pc2VXYWl0KDEwMCkpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSBhY3RpdmVUZXN0Rml4dHVyZXNbYWN0aXZlVGVzdEZpeHR1cmVzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoIWxpc3QpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ25zVGVzdEJlZFJlbmRlciBjYWxsZWQgd2l0aG91dCBuc1Rlc3RCZWRCZWZvcmVFYWNoL25zVGVzdEJlZEFmdGVyIGVhY2guICcgKyBcIllvdSBhcmUgcmVzcG9uc2libGUgZm9yIGNhbGxpbmcgJ2ZpeHR1cmUuZGVzdHJveSgpJyB3aGVuIHlvdXIgdGVzdCBpcyBkb25lIFwiICsgJ2luIG9yZGVyIHRvIGNsZWFuIHVwIHRoZSBjb21wb25lbnRzIHRoYXQgYXJlIGNyZWF0ZWQuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGlzdC5wdXNoKGZpeHR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaXh0dXJlO1xuICAgICAgfSlcbiAgKTtcbn1cbiJdfQ==