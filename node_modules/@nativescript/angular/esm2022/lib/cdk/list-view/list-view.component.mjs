import { __decorate, __metadata } from "tslib";
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, Directive, ElementRef, EventEmitter, forwardRef, Host, HostListener, inject, Inject, InjectionToken, Input, IterableDiffers, Output, TemplateRef, ViewChild, ViewContainerRef } from '@angular/core';
import { LayoutBase, ObservableArray, profile } from '@nativescript/core';
import { extractSingleViewRecursive } from '../../element-registry/registry';
import { NativeScriptDebug } from '../../trace';
import { isListLikeIterable } from '../../utils/general';
import { DetachedLoader } from '../detached-loader';
import * as i0 from "@angular/core";
const NG_VIEW = '_ngViewRef';
export const TEMPLATED_ITEMS_COMPONENT = new InjectionToken('TemplatedItemsComponent');
export class ItemContext {
    constructor($implicit, item, index, even, odd) {
        this.$implicit = $implicit;
        this.item = item;
        this.index = index;
        this.even = even;
        this.odd = odd;
    }
}
export class NsTemplatedItem {
    constructor(template, location, onCreate) {
        this.template = template;
        this.location = location;
        this.onCreate = onCreate;
    }
    create(context) {
        const viewRef = this.location.createEmbeddedView(this.template, context ? this.setupItemContext(context) : new ItemContext());
        viewRef.detach(); // create detached, just beware this doesn't always work and the view might run the first CD anyway.
        const resultView = getItemViewRoot(viewRef);
        resultView[NG_VIEW] = viewRef;
        if (this.onCreate) {
            this.onCreate(resultView);
        }
        return resultView;
    }
    update(view, context) {
        const viewRef = this.getEmbeddedViewRef(view);
        this.setupItemContext(context, viewRef);
        viewRef?.detectChanges();
    }
    attach(view) {
        const viewRef = this.getEmbeddedViewRef(view);
        viewRef?.reattach();
        viewRef?.detectChanges();
    }
    detach(view) {
        const viewRef = this.getEmbeddedViewRef(view);
        viewRef?.detach();
    }
    dispose(view) {
        const viewRef = this.getEmbeddedViewRef(view);
        viewRef?.destroy();
    }
    getEmbeddedViewRef(view) {
        let viewRef = view[NG_VIEW];
        // Getting angular view from original element (in cases when ProxyViewContainer
        // is used NativeScript internally wraps it in a StackLayout)
        if (!viewRef && view instanceof LayoutBase && view.getChildrenCount() > 0) {
            viewRef = view.getChildAt(0)[NG_VIEW];
        }
        return viewRef;
    }
    isValid(view) {
        return !!this.getEmbeddedViewRef(view);
    }
    setupItemContext({ index, data }, oldView) {
        const context = oldView ? oldView.context : new ItemContext();
        context.$implicit = data;
        context.item = data;
        context.index = index;
        context.even = index % 2 === 0;
        context.odd = !context.even;
        return context;
    }
}
export class ListViewComponent {
    get nativeElement() {
        return this.templatedItemsView;
    }
    get items() {
        return this._items;
    }
    set items(value) {
        this._items = value;
        let needDiffer = true;
        if (value instanceof ObservableArray) {
            needDiffer = false;
        }
        if (needDiffer && !this._differ && isListLikeIterable(value)) {
            this._differ = this._iterableDiffers.find(this._items).create((_index, item) => {
                return item;
            });
        }
        this.templatedItemsView.items = this._items;
    }
    // this elementRef is only here for backwards compatibility reasons
    constructor(_elementRef) {
        this._iterableDiffers = inject(IterableDiffers);
        this._changeDetectorRef = inject(ChangeDetectorRef);
        this._elementRef = inject(ElementRef);
        // I believe this only exists so this can be inherited and people can override it.
        this.templatedItemsView = this._elementRef.nativeElement;
        this._viewToTemplate = new WeakMap();
        this.setupItemView = new EventEmitter();
        if (_elementRef) {
            this.templatedItemsView = _elementRef.nativeElement;
        }
    }
    ngAfterContentInit() {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.listViewLog('TemplatedItemsView.ngAfterContentInit()');
        }
        this.setItemTemplates();
    }
    ngOnDestroy() {
        this.templatedItemsView = null;
        if (this._templateMap) {
            this._templateMap.clear();
        }
    }
    setItemTemplates() {
        // The itemTemplateQuery may be changed after list items are added that contain <template> inside,
        // so cache and use only the original template to avoid errors.
        this.fallbackItemTemplate = this.itemTemplateQuery;
        if (this.fallbackItemTemplate && !this._templateMap?.has('default')) {
            // apparently you can create a Core ListView without a template...
            // we also add a fallback default for when the user sets multiple templates but no templateSelector
            this.registerTemplate('default', this.fallbackItemTemplate);
        }
        if (this._templateMap) {
            // sometimes templates are registered before loader is ready, so we update here
            this._templateMap.forEach((t) => (t.location = this.loader));
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.listViewLog('Setting templates');
            }
            const templates = [];
            this._templateMap.forEach((value, key) => {
                templates.push({
                    createView: () => null, // we'll handle creation later, otherwise core will create an invalid template
                    key,
                });
            });
            this.templatedItemsView.itemTemplates = templates;
        }
    }
    registerTemplate(key, template) {
        if (NativeScriptDebug.isLogEnabled()) {
            NativeScriptDebug.listViewLog(`registerTemplate for key: ${key}, ${this.loader}`);
        }
        if (!this._templateMap) {
            this._templateMap = new Map();
        }
        this._templateMap.set(key, new NsTemplatedItem(template, this.loader, (v) => this._viewToTemplate.set(v, key)));
    }
    onItemLoading(args) {
        if (!this._templateMap) {
            return;
        }
        const index = args.index;
        const lview = args.object;
        const items = lview.items;
        const currentItem = 'getItem' in items && typeof items.getItem === 'function' ? items.getItem(index) : items[index];
        let template;
        if (args.view) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.listViewLog(`onItemLoading: ${index} - Reusing existing view`);
            }
            let templateKey = this._viewToTemplate.get(args.view);
            if (!templateKey && args.view instanceof LayoutBase && args.view.getChildrenCount() > 0) {
                templateKey = this._viewToTemplate.get(args.view.getChildAt(0));
            }
            if (!templateKey) {
                // this template was not created by us
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.listViewError(`ViewReference not found for item ${index}. View recycling is not working`);
                }
                return;
            }
            template = this._templateMap.get(templateKey);
            template.update(args.view, { index, data: currentItem });
        }
        else {
            // this should never enter if it creates the view
            const templateKey = typeof lview.itemTemplateSelector === 'function' ? lview.itemTemplateSelector(currentItem, index, items) : 'default';
            template = this._templateMap.get(templateKey);
            if (!template) {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.listViewError(`Template for key '${templateKey}' not found.`);
                }
                return;
            }
            args.view = template.create({ index, data: currentItem });
        }
        this.setupViewRef(template.getEmbeddedViewRef(args.view), currentItem, index, args.view);
        template.attach(args.view);
        this._changeDetectorRef.detectChanges();
    }
    setupViewRef(viewRef, data, index, nativeElement) {
        const context = viewRef.context;
        this.setupItemView.next({ view: viewRef, nativeElement, data: data, index: index, context: context });
    }
    ngDoCheck() {
        if (this._differ) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.listViewLog('ngDoCheck() - execute differ');
            }
            const changes = this._differ.diff(this._items);
            if (changes) {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.listViewLog('ngDoCheck() - refresh');
                }
                this.templatedItemsView.refresh();
            }
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: ListViewComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.1.0", type: ListViewComponent, isStandalone: true, selector: "ListView", inputs: { items: "items" }, outputs: { setupItemView: "setupItemView" }, host: { listeners: { "itemLoading": "onItemLoading($event)" } }, providers: [{ provide: TEMPLATED_ITEMS_COMPONENT, useExisting: forwardRef(() => ListViewComponent) }], queries: [{ propertyName: "itemTemplateQuery", first: true, predicate: TemplateRef, descendants: true, read: TemplateRef }], viewQueries: [{ propertyName: "loader", first: true, predicate: ["loader"], descendants: true, read: ViewContainerRef, static: true }], ngImport: i0, template: `<DetachedContainer>
    <ng-container #loader></ng-container>
  </DetachedContainer>`, isInline: true, dependencies: [{ kind: "component", type: DetachedLoader, selector: "DetachedContainer" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
__decorate([
    profile,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], ListViewComponent.prototype, "onItemLoading", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: ListViewComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: 'ListView',
                    template: `<DetachedContainer>
    <ng-container #loader></ng-container>
  </DetachedContainer>`,
                    standalone: true,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    imports: [DetachedLoader],
                    providers: [{ provide: TEMPLATED_ITEMS_COMPONENT, useExisting: forwardRef(() => ListViewComponent) }],
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { loader: [{
                type: ViewChild,
                args: ['loader', { read: ViewContainerRef, static: true }]
            }], setupItemView: [{
                type: Output
            }], itemTemplateQuery: [{
                type: ContentChild,
                args: [TemplateRef, { read: TemplateRef, static: false }]
            }], items: [{
                type: Input
            }], onItemLoading: [{
                type: HostListener,
                args: ['itemLoading', ['$event']]
            }] } });
export function getItemViewRoot(viewRef, rootLocator = extractSingleViewRecursive) {
    const rootView = rootLocator(viewRef.rootNodes, 0);
    return rootView;
}
// eslint-disable-next-line @angular-eslint/directive-selector
export class TemplateKeyDirective {
    constructor(templateRef, comp) {
        this.templateRef = templateRef;
        this.comp = comp;
    }
    set nsTemplateKey(value) {
        if (this.comp && this.templateRef) {
            this.comp.registerTemplate(value, this.templateRef);
        }
    }
    set nsTemplateKeys(values) {
        // single template with multiple keys
        if (this.comp && this.templateRef && values) {
            values.forEach((value) => this.comp.registerTemplate(value, this.templateRef));
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: TemplateKeyDirective, deps: [{ token: i0.TemplateRef }, { token: TEMPLATED_ITEMS_COMPONENT, host: true }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.1.0", type: TemplateKeyDirective, isStandalone: true, selector: "[nsTemplateKey],[nsTemplateKeys]", inputs: { nsTemplateKey: "nsTemplateKey", nsTemplateKeys: "nsTemplateKeys" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.0", ngImport: i0, type: TemplateKeyDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nsTemplateKey],[nsTemplateKeys]',
                    standalone: true,
                }]
        }], ctorParameters: () => [{ type: i0.TemplateRef }, { type: undefined, decorators: [{
                    type: Host
                }, {
                    type: Inject,
                    args: [TEMPLATED_ITEMS_COMPONENT]
                }] }], propDecorators: { nsTemplateKey: [{
                type: Input
            }], nsTemplateKeys: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGlzdC12aWV3LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2FuZ3VsYXIvc3JjL2xpYi9jZGsvbGlzdC12aWV3L2xpc3Qtdmlldy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBb0IsdUJBQXVCLEVBQUUsaUJBQWlCLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQVcsVUFBVSxFQUFtQixZQUFZLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxjQUFjLEVBQUUsS0FBSyxFQUFrQixlQUFlLEVBQXFCLE1BQU0sRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2xXLE9BQU8sRUFBZ0MsVUFBVSxFQUFZLGVBQWUsRUFBRSxPQUFPLEVBQVEsTUFBTSxvQkFBb0IsQ0FBQztBQUV4SCxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUM3RSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDaEQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFFekQsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG9CQUFvQixDQUFDOztBQUVwRCxNQUFNLE9BQU8sR0FBRyxZQUFZLENBQUM7QUFNN0IsTUFBTSxDQUFDLE1BQU0seUJBQXlCLEdBQUcsSUFBSSxjQUFjLENBQXFCLHlCQUF5QixDQUFDLENBQUM7QUFFM0csTUFBTSxPQUFPLFdBQVc7SUFDdEIsWUFBbUIsU0FBYSxFQUFTLElBQVEsRUFBUyxLQUFjLEVBQVMsSUFBYyxFQUFTLEdBQWE7UUFBbEcsY0FBUyxHQUFULFNBQVMsQ0FBSTtRQUFTLFNBQUksR0FBSixJQUFJLENBQUk7UUFBUyxVQUFLLEdBQUwsS0FBSyxD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QU0sT0FBTyxvQkFBb0I7SUFDL0IsWUFBb0IsV0FBMkIsRUFBcUQsSUFBMkI7UUFBM0csZ0JBQVcsR0FBWCxXQUFXLENBQWdCO1FBQXFELFNBQUksR0FBSixJQUFJLENBQXVCO0lBQUcsQ0FBQztJQUVuSSxJQUNJLGFBQWEsQ0FBQyxLQUFhO1FBQzdCLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDbEMsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3RELENBQUM7SUFDSCxDQUFDO0lBQ0QsSUFDSSxjQUFjLENBQUMsTUFBZ0I7UUFDakMscUNBQXFDO1FBQ3JDLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsV0FBVyxJQUFJLE1BQU0sRUFBRSxDQUFDO1lBQzVDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1FBQ2pGLENBQUM7SUFDSCxDQUFDOzhHQWZVLG9CQUFvQiw2Q0FDa0MseUJBQXlCO2tHQUQvRSxvQkFBb0I7OzJGQUFwQixvQkFBb0I7a0JBSmhDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLGtDQUFrQztvQkFDNUMsVUFBVSxFQUFFLElBQUk7aUJBQ2pCOzswQkFFbUQsSUFBSTs7MEJBQUksTUFBTTsyQkFBQyx5QkFBeUI7eUNBR3RGLGFBQWE7c0JBRGhCLEtBQUs7Z0JBT0YsY0FBYztzQkFEakIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIERpcmVjdGl2ZSwgRG9DaGVjaywgRWxlbWVudFJlZiwgRW1iZWRkZWRWaWV3UmVmLCBFdmVudEVtaXR0ZXIsIGZvcndhcmRSZWYsIEhvc3QsIEhvc3RMaXN0ZW5lciwgaW5qZWN0LCBJbmplY3QsIEluamVjdGlvblRva2VuLCBJbnB1dCwgSXRlcmFibGVEaWZmZXIsIEl0ZXJhYmxlRGlmZmVycywgTmdab25lLCBPbkRlc3Ryb3ksIE91dHB1dCwgVGVtcGxhdGVSZWYsIFZpZXdDaGlsZCwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSXRlbUV2ZW50RGF0YSwgS2V5ZWRUZW1wbGF0ZSwgTGF5b3V0QmFzZSwgTGlzdFZpZXcsIE9ic2VydmFibGVBcnJheSwgcHJvZmlsZSwgVmlldyB9IGZyb20gJ0BuYXRpdmVzY3JpcHQvY29yZSc7XG5cbmltcG9ydCB7IGV4dHJhY3RTaW5nbGVWaWV3UmVjdXJzaXZlIH0gZnJvbSAnLi4vLi4vZWxlbWVudC1yZWdpc3RyeS9yZWdpc3RyeSc7XG5pbXBvcnQgeyBOYXRpdmVTY3JpcHREZWJ1ZyB9IGZyb20gJy4uLy4uL3RyYWNlJztcbmltcG9ydCB7IGlzTGlzdExpa2VJdGVyYWJsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2dlbmVyYWwnO1xuaW1wb3J0IHsgTmdWaWV3VGVtcGxhdGUgfSBmcm9tICcuLi8uLi92aWV3LXJlZnMnO1xuaW1wb3J0IHsgRGV0YWNoZWRMb2FkZXIgfSBmcm9tICcuLi9kZXRhY2hlZC1sb2FkZXInO1xuXG5jb25zdCBOR19WSUVXID0gJ19uZ1ZpZXdSZWYnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRlbXBsYXRlZEl0ZW1zSG9zdDxUID0gYW55PiB7XG4gIHJlZ2lzdGVyVGVtcGxhdGUoa2V5OiBzdHJpbmcsIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxUPik7XG59XG5cbmV4cG9ydCBjb25zdCBURU1QTEFURURfSVRFTVNfQ09NUE9ORU5UID0gbmV3IEluamVjdGlvblRva2VuPFRlbXBsYXRlZEl0ZW1zSG9zdD4oJ1RlbXBsYXRlZEl0ZW1zQ29tcG9uZW50Jyk7XG5cbmV4cG9ydCBjbGFzcyBJdGVtQ29udGV4dDxUPiB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyAkaW1wbGljaXQ/OiBULCBwdWJsaWMgaXRlbT86IFQsIHB1YmxpYyBpbmRleD86IG51bWJlciwgcHVibGljIGV2ZW4/OiBib29sZWFuLCBwdWJsaWMgb2RkPzogYm9vbGVhbikge31cbn1cblxuZXhwb3J0IGNsYXNzIE5zVGVtcGxhdGVkSXRlbTxUPiBpbXBsZW1lbnRzIE5nVmlld1RlbXBsYXRlPHsgaW5kZXg6IG51bWJlcjsgZGF0YTogVCB9PiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdGVtcGxhdGU6IFRlbXBsYXRlUmVmPEl0ZW1Db250ZXh0PFQ+PiwgcHVibGljIGxvY2F0aW9uOiBWaWV3Q29udGFpbmVyUmVmLCBwcml2YXRlIG9uQ3JlYXRlPzogKHZpZXc6IFZpZXcpID0+IHZvaWQpIHt9XG4gIGNyZWF0ZShjb250ZXh0PzogeyBpbmRleDogbnVtYmVyOyBkYXRhOiBUIH0pOiBWaWV3IHtcbiAgICBjb25zdCB2aWV3UmVmID0gdGhpcy5sb2NhdGlvbi5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy50ZW1wbGF0ZSwgY29udGV4dCA/IHRoaXMuc2V0dXBJdGVtQ29udGV4dChjb250ZXh0KSA6IG5ldyBJdGVtQ29udGV4dCgpKTtcbiAgICB2aWV3UmVmLmRldGFjaCgpOyAvLyBjcmVhdGUgZGV0YWNoZWQsIGp1c3QgYmV3YXJlIHRoaXMgZG9lc24ndCBhbHdheXMgd29yayBhbmQgdGhlIHZpZXcgbWlnaHQgcnVuIHRoZSBmaXJzdCBDRCBhbnl3YXkuXG4gICAgY29uc3QgcmVzdWx0VmlldyA9IGdldEl0ZW1WaWV3Um9vdCh2aWV3UmVmKTtcbiAgICByZXN1bHRWaWV3W05HX1ZJRVddID0gdmlld1JlZjtcbiAgICBpZiAodGhpcy5vbkNyZWF0ZSkge1xuICAgICAgdGhpcy5vbkNyZWF0ZShyZXN1bHRWaWV3KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFZpZXc7XG4gIH1cbiAgdXBkYXRlKHZpZXc6IFZpZXcsIGNvbnRleHQ/OiB7IGluZGV4OiBudW1iZXI7IGRhdGE6IFQgfSk6IHZvaWQge1xuICAgIGNvbnN0IHZpZXdSZWYgPSB0aGlzLmdldEVtYmVkZGVkVmlld1JlZih2aWV3KTtcbiAgICB0aGlzLnNldHVwSXRlbUNvbnRleHQoY29udGV4dCwgdmlld1JlZik7XG4gICAgdmlld1JlZj8uZGV0ZWN0Q2hhbmdlcygpO1xuICB9XG4gIGF0dGFjaCh2aWV3OiBWaWV3KTogdm9pZCB7XG4gICAgY29uc3Qgdmlld1JlZiA9IHRoaXMuZ2V0RW1iZWRkZWRWaWV3UmVmKHZpZXcpO1xuICAgIHZpZXdSZWY/LnJlYXR0YWNoKCk7XG4gICAgdmlld1JlZj8uZGV0ZWN0Q2hhbmdlcygpO1xuICB9XG4gIGRldGFjaCh2aWV3OiBWaWV3KTogdm9pZCB7XG4gICAgY29uc3Qgdmlld1JlZiA9IHRoaXMuZ2V0RW1iZWRkZWRWaWV3UmVmKHZpZXcpO1xuICAgIHZpZXdSZWY/LmRldGFjaCgpO1xuICB9XG4gIGRpc3Bvc2UodmlldzogVmlldyk6IHZvaWQge1xuICAgIGNvbnN0IHZpZXdSZWYgPSB0aGlzLmdldEVtYmVkZGVkVmlld1JlZih2aWV3KTtcbiAgICB2aWV3UmVmPy5kZXN0cm95KCk7XG4gIH1cblxuICBnZXRFbWJlZGRlZFZpZXdSZWYodmlldzogVmlldyk6IEVtYmVkZGVkVmlld1JlZjxJdGVtQ29udGV4dDxUPj4gfCB1bmRlZmluZWQge1xuICAgIGxldCB2aWV3UmVmID0gdmlld1tOR19WSUVXXTtcblxuICAgIC8vIEdldHRpbmcgYW5ndWxhciB2aWV3IGZyb20gb3JpZ2luYWwgZWxlbWVudCAoaW4gY2FzZXMgd2hlbiBQcm94eVZpZXdDb250YWluZXJcbiAgICAvLyBpcyB1c2VkIE5hdGl2ZVNjcmlwdCBpbnRlcm5hbGx5IHdyYXBzIGl0IGluIGEgU3RhY2tMYXlvdXQpXG4gICAgaWYgKCF2aWV3UmVmICYmIHZpZXcgaW5zdGFuY2VvZiBMYXlvdXRCYXNlICYmIHZpZXcuZ2V0Q2hpbGRyZW5Db3VudCgpID4gMCkge1xuICAgICAgdmlld1JlZiA9IHZpZXcuZ2V0Q2hpbGRBdCgwKVtOR19WSUVXXTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXdSZWY7XG4gIH1cblxuICBpc1ZhbGlkKHZpZXc6IFZpZXcpIHtcbiAgICByZXR1cm4gISF0aGlzLmdldEVtYmVkZGVkVmlld1JlZih2aWV3KTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBJdGVtQ29udGV4dCh7IGluZGV4LCBkYXRhIH06IHsgaW5kZXg6IG51bWJlcjsgZGF0YTogVCB9LCBvbGRWaWV3PzogRW1iZWRkZWRWaWV3UmVmPEl0ZW1Db250ZXh0PFQ+Pik6IEl0ZW1Db250ZXh0PFQ+IHtcbiAgICBjb25zdCBjb250ZXh0OiBJdGVtQ29udGV4dDxUPiA9IG9sZFZpZXcgPyBvbGRWaWV3LmNvbnRleHQgOiBuZXcgSXRlbUNvbnRleHQ8VD4oKTtcbiAgICBjb250ZXh0LiRpbXBsaWNpdCA9IGRhdGE7XG4gICAgY29udGV4dC5pdGVtID0gZGF0YTtcbiAgICBjb250ZXh0LmluZGV4ID0gaW5kZXg7XG4gICAgY29udGV4dC5ldmVuID0gaW5kZXggJSAyID09PSAwO1xuICAgIGNvbnRleHQub2RkID0gIWNvbnRleHQuZXZlbjtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNldHVwSXRlbVZpZXdBcmdzPFQ+IHtcbiAgdmlldzogRW1iZWRkZWRWaWV3UmVmPEl0ZW1Db250ZXh0PFQ+PjtcbiAgbmF0aXZlRWxlbWVudDogVmlldztcbiAgZGF0YTogVDtcbiAgaW5kZXg6IG51bWJlcjtcbiAgY29udGV4dDogSXRlbUNvbnRleHQ8VD47XG59XG5cbkBDb21wb25lbnQoe1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGFuZ3VsYXItZXNsaW50L2NvbXBvbmVudC1zZWxlY3RvclxuICBzZWxlY3RvcjogJ0xpc3RWaWV3JyxcbiAgdGVtcGxhdGU6IGA8RGV0YWNoZWRDb250YWluZXI+XG4gICAgPG5nLWNvbnRhaW5lciAjbG9hZGVyPjwvbmctY29udGFpbmVyPlxuICA8L0RldGFjaGVkQ29udGFpbmVyPmAsXG4gIHN0YW5kYWxvbmU6IHRydWUsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBpbXBvcnRzOiBbRGV0YWNoZWRMb2FkZXJdLFxuICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IFRFTVBMQVRFRF9JVEVNU19DT01QT05FTlQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IExpc3RWaWV3Q29tcG9uZW50KSB9XSxcbn0pXG5leHBvcnQgY2xhc3MgTGlzdFZpZXdDb21wb25lbnQ8VCA9IGFueT4gaW1wbGVtZW50cyBEb0NoZWNrLCBPbkRlc3Ryb3ksIEFmdGVyQ29udGVudEluaXQsIFRlbXBsYXRlZEl0ZW1zSG9zdCB7XG4gIHB1YmxpYyBnZXQgbmF0aXZlRWxlbWVudCgpOiBMaXN0VmlldyB7XG4gICAgcmV0dXJuIHRoaXMudGVtcGxhdGVkSXRlbXNWaWV3O1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkb25seSBfaXRlcmFibGVEaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMgPSBpbmplY3QoSXRlcmFibGVEaWZmZXJzKTtcbiAgcHJpdmF0ZSByZWFkb25seSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmID0gaW5qZWN0KENoYW5nZURldGVjdG9yUmVmKTtcbiAgcHJpdmF0ZSByZWFkb25seSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiA9IGluamVjdChFbGVtZW50UmVmKTtcblxuICAvLyBJIGJlbGlldmUgdGhpcyBvbmx5IGV4aXN0cyBzbyB0aGlzIGNhbiBiZSBpbmhlcml0ZWQgYW5kIHBlb3BsZSBjYW4gb3ZlcnJpZGUgaXQuXG4gIHByb3RlY3RlZCB0ZW1wbGF0ZWRJdGVtc1ZpZXc6IExpc3RWaWV3ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICBwcm90ZWN0ZWQgX2l0ZW1zOiBUW10gfCBPYnNlcnZhYmxlQXJyYXk8VD47XG4gIHByb3RlY3RlZCBfZGlmZmVyOiBJdGVyYWJsZURpZmZlcjxUPjtcbiAgcHJvdGVjdGVkIF90ZW1wbGF0ZU1hcDogTWFwPHN0cmluZywgTnNUZW1wbGF0ZWRJdGVtPFQ+PjtcbiAgcHJvdGVjdGVkIF92aWV3VG9UZW1wbGF0ZTogV2Vha01hcDxWaWV3LCBzdHJpbmc+ID0gbmV3IFdlYWtNYXA8Vmlldywgc3RyaW5nPigpO1xuXG4gIEBWaWV3Q2hpbGQoJ2xvYWRlcicsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiwgc3RhdGljOiB0cnVlIH0pIGxvYWRlcjogVmlld0NvbnRhaW5lclJlZjtcblxuICBAT3V0cHV0KCkgcHVibGljIHNldHVwSXRlbVZpZXcgPSBuZXcgRXZlbnRFbWl0dGVyPFNldHVwSXRlbVZpZXdBcmdzPFQ+PigpO1xuXG4gIEBDb250ZW50Q2hpbGQoVGVtcGxhdGVSZWYsIHsgcmVhZDogVGVtcGxhdGVSZWYsIHN0YXRpYzogZmFsc2UgfSkgaXRlbVRlbXBsYXRlUXVlcnk6IFRlbXBsYXRlUmVmPEl0ZW1Db250ZXh0PFQ+PjtcblxuICBmYWxsYmFja0l0ZW1UZW1wbGF0ZTogVGVtcGxhdGVSZWY8SXRlbUNvbnRleHQ8VD4+O1xuXG4gIEBJbnB1dCgpXG4gIGdldCBpdGVtcygpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXM7XG4gIH1cblxuICBzZXQgaXRlbXModmFsdWU6IFRbXSB8IE9ic2VydmFibGVBcnJheTxUPikge1xuICAgIHRoaXMuX2l0ZW1zID0gdmFsdWU7XG4gICAgbGV0IG5lZWREaWZmZXIgPSB0cnVlO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9ic2VydmFibGVBcnJheSkge1xuICAgICAgbmVlZERpZmZlciA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobmVlZERpZmZlciAmJiAhdGhpcy5fZGlmZmVyICYmIGlzTGlzdExpa2VJdGVyYWJsZSh2YWx1ZSkpIHtcbiAgICAgIHRoaXMuX2RpZmZlciA9IHRoaXMuX2l0ZXJhYmxlRGlmZmVycy5maW5kKHRoaXMuX2l0ZW1zKS5jcmVhdGUoKF9pbmRleCwgaXRlbSkgPT4ge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMudGVtcGxhdGVkSXRlbXNWaWV3Lml0ZW1zID0gdGhpcy5faXRlbXM7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgX2l0ZXJhYmxlRGlmZmVyczogSXRlcmFibGVEaWZmZXJzLCBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmKTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgX2l0ZXJhYmxlRGlmZmVyczogSXRlcmFibGVEaWZmZXJzLCBfbmdab25lOiBOZ1pvbmUpO1xuICBjb25zdHJ1Y3RvcigpO1xuICAvLyB0aGlzIGVsZW1lbnRSZWYgaXMgb25seSBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSByZWFzb25zXG4gIGNvbnN0cnVjdG9yKF9lbGVtZW50UmVmPzogRWxlbWVudFJlZikge1xuICAgIGlmIChfZWxlbWVudFJlZikge1xuICAgICAgdGhpcy50ZW1wbGF0ZWRJdGVtc1ZpZXcgPSBfZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICBpZiAoTmF0aXZlU2NyaXB0RGVidWcuaXNMb2dFbmFibGVkKCkpIHtcbiAgICAgIE5hdGl2ZVNjcmlwdERlYnVnLmxpc3RWaWV3TG9nKCdUZW1wbGF0ZWRJdGVtc1ZpZXcubmdBZnRlckNvbnRlbnRJbml0KCknKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEl0ZW1UZW1wbGF0ZXMoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMudGVtcGxhdGVkSXRlbXNWaWV3ID0gbnVsbDtcblxuICAgIGlmICh0aGlzLl90ZW1wbGF0ZU1hcCkge1xuICAgICAgdGhpcy5fdGVtcGxhdGVNYXAuY2xlYXIoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNldEl0ZW1UZW1wbGF0ZXMoKSB7XG4gICAgLy8gVGhlIGl0ZW1UZW1wbGF0ZVF1ZXJ5IG1heSBiZSBjaGFuZ2VkIGFmdGVyIGxpc3QgaXRlbXMgYXJlIGFkZGVkIHRoYXQgY29udGFpbiA8dGVtcGxhdGU+IGluc2lkZSxcbiAgICAvLyBzbyBjYWNoZSBhbmQgdXNlIG9ubHkgdGhlIG9yaWdpbmFsIHRlbXBsYXRlIHRvIGF2b2lkIGVycm9ycy5cbiAgICB0aGlzLmZhbGxiYWNrSXRlbVRlbXBsYXRlID0gdGhpcy5pdGVtVGVtcGxhdGVRdWVyeTtcbiAgICBpZiAodGhpcy5mYWxsYmFja0l0ZW1UZW1wbGF0ZSAmJiAhdGhpcy5fdGVtcGxhdGVNYXA/LmhhcygnZGVmYXVsdCcpKSB7XG4gICAgICAvLyBhcHBhcmVudGx5IHlvdSBjYW4gY3JlYXRlIGEgQ29yZSBMaXN0VmlldyB3aXRob3V0IGEgdGVtcGxhdGUuLi5cbiAgICAgIC8vIHdlIGFsc28gYWRkIGEgZmFsbGJhY2sgZGVmYXVsdCBmb3Igd2hlbiB0aGUgdXNlciBzZXRzIG11bHRpcGxlIHRlbXBsYXRlcyBidXQgbm8gdGVtcGxhdGVTZWxlY3RvclxuICAgICAgdGhpcy5yZWdpc3RlclRlbXBsYXRlKCdkZWZhdWx0JywgdGhpcy5mYWxsYmFja0l0ZW1UZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3RlbXBsYXRlTWFwKSB7XG4gICAgICAvLyBzb21ldGltZXMgdGVtcGxhdGVzIGFyZSByZWdpc3RlcmVkIGJlZm9yZSBsb2FkZXIgaXMgcmVhZHksIHNvIHdlIHVwZGF0ZSBoZXJlXG4gICAgICB0aGlzLl90ZW1wbGF0ZU1hcC5mb3JFYWNoKCh0KSA9PiAodC5sb2NhdGlvbiA9IHRoaXMubG9hZGVyKSk7XG4gICAgICBpZiAoTmF0aXZlU2NyaXB0RGVidWcuaXNMb2dFbmFibGVkKCkpIHtcbiAgICAgICAgTmF0aXZlU2NyaXB0RGVidWcubGlzdFZpZXdMb2coJ1NldHRpbmcgdGVtcGxhdGVzJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRlbXBsYXRlczogS2V5ZWRUZW1wbGF0ZVtdID0gW107XG4gICAgICB0aGlzLl90ZW1wbGF0ZU1hcC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHRlbXBsYXRlcy5wdXNoKHtcbiAgICAgICAgICBjcmVhdGVWaWV3OiAoKSA9PiBudWxsLCAvLyB3ZSdsbCBoYW5kbGUgY3JlYXRpb24gbGF0ZXIsIG90aGVyd2lzZSBjb3JlIHdpbGwgY3JlYXRlIGFuIGludmFsaWQgdGVtcGxhdGVcbiAgICAgICAgICBrZXksXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnRlbXBsYXRlZEl0ZW1zVmlldy5pdGVtVGVtcGxhdGVzID0gdGVtcGxhdGVzO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZWdpc3RlclRlbXBsYXRlKGtleTogc3RyaW5nLCB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8SXRlbUNvbnRleHQ8VD4+KSB7XG4gICAgaWYgKE5hdGl2ZVNjcmlwdERlYnVnLmlzTG9nRW5hYmxlZCgpKSB7XG4gICAgICBOYXRpdmVTY3JpcHREZWJ1Zy5saXN0Vmlld0xvZyhgcmVnaXN0ZXJUZW1wbGF0ZSBmb3Iga2V5OiAke2tleX0sICR7dGhpcy5sb2FkZXJ9YCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl90ZW1wbGF0ZU1hcCkge1xuICAgICAgdGhpcy5fdGVtcGxhdGVNYXAgPSBuZXcgTWFwPHN0cmluZywgTnNUZW1wbGF0ZWRJdGVtPFQ+PigpO1xuICAgIH1cblxuICAgIHRoaXMuX3RlbXBsYXRlTWFwLnNldChrZXksIG5ldyBOc1RlbXBsYXRlZEl0ZW08VD4odGVtcGxhdGUsIHRoaXMubG9hZGVyLCAodikgPT4gdGhpcy5fdmlld1RvVGVtcGxhdGUuc2V0KHYsIGtleSkpKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2l0ZW1Mb2FkaW5nJywgWyckZXZlbnQnXSlcbiAgQHByb2ZpbGVcbiAgcHVibGljIG9uSXRlbUxvYWRpbmcoYXJnczogSXRlbUV2ZW50RGF0YSkge1xuICAgIGlmICghdGhpcy5fdGVtcGxhdGVNYXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleCA9IGFyZ3MuaW5kZXg7XG4gICAgY29uc3QgbHZpZXc6IExpc3RWaWV3ID0gPExpc3RWaWV3PmFyZ3Mub2JqZWN0O1xuICAgIGNvbnN0IGl0ZW1zID0gbHZpZXcuaXRlbXM7XG4gICAgY29uc3QgY3VycmVudEl0ZW0gPSAnZ2V0SXRlbScgaW4gaXRlbXMgJiYgdHlwZW9mIGl0ZW1zLmdldEl0ZW0gPT09ICdmdW5jdGlvbicgPyBpdGVtcy5nZXRJdGVtKGluZGV4KSA6IGl0ZW1zW2luZGV4XTtcblxuICAgIGxldCB0ZW1wbGF0ZTogTnNUZW1wbGF0ZWRJdGVtPFQ+O1xuXG4gICAgaWYgKGFyZ3Mudmlldykge1xuICAgICAgaWYgKE5hdGl2ZVNjcmlwdERlYnVnLmlzTG9nRW5hYmxlZCgpKSB7XG4gICAgICAgIE5hdGl2ZVNjcmlwdERlYnVnLmxpc3RWaWV3TG9nKGBvbkl0ZW1Mb2FkaW5nOiAke2luZGV4fSAtIFJldXNpbmcgZXhpc3Rpbmcgdmlld2ApO1xuICAgICAgfVxuXG4gICAgICBsZXQgdGVtcGxhdGVLZXkgPSB0aGlzLl92aWV3VG9UZW1wbGF0ZS5nZXQoYXJncy52aWV3KTtcbiAgICAgIGlmICghdGVtcGxhdGVLZXkgJiYgYXJncy52aWV3IGluc3RhbmNlb2YgTGF5b3V0QmFzZSAmJiBhcmdzLnZpZXcuZ2V0Q2hpbGRyZW5Db3VudCgpID4gMCkge1xuICAgICAgICB0ZW1wbGF0ZUtleSA9IHRoaXMuX3ZpZXdUb1RlbXBsYXRlLmdldChhcmdzLnZpZXcuZ2V0Q2hpbGRBdCgwKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRlbXBsYXRlS2V5KSB7XG4gICAgICAgIC8vIHRoaXMgdGVtcGxhdGUgd2FzIG5vdCBjcmVhdGVkIGJ5IHVzXG4gICAgICAgIGlmIChOYXRpdmVTY3JpcHREZWJ1Zy5pc0xvZ0VuYWJsZWQoKSkge1xuICAgICAgICAgIE5hdGl2ZVNjcmlwdERlYnVnLmxpc3RWaWV3RXJyb3IoYFZpZXdSZWZlcmVuY2Ugbm90IGZvdW5kIGZvciBpdGVtICR7aW5kZXh9LiBWaWV3IHJlY3ljbGluZyBpcyBub3Qgd29ya2luZ2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRlbXBsYXRlID0gdGhpcy5fdGVtcGxhdGVNYXAuZ2V0KHRlbXBsYXRlS2V5KTtcbiAgICAgIHRlbXBsYXRlLnVwZGF0ZShhcmdzLnZpZXcsIHsgaW5kZXgsIGRhdGE6IGN1cnJlbnRJdGVtIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGlzIHNob3VsZCBuZXZlciBlbnRlciBpZiBpdCBjcmVhdGVzIHRoZSB2aWV3XG4gICAgICBjb25zdCB0ZW1wbGF0ZUtleSA9IHR5cGVvZiBsdmlldy5pdGVtVGVtcGxhdGVTZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJyA/IGx2aWV3Lml0ZW1UZW1wbGF0ZVNlbGVjdG9yKGN1cnJlbnRJdGVtLCBpbmRleCwgaXRlbXMpIDogJ2RlZmF1bHQnO1xuICAgICAgdGVtcGxhdGUgPSB0aGlzLl90ZW1wbGF0ZU1hcC5nZXQodGVtcGxhdGVLZXkpO1xuICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAoTmF0aXZlU2NyaXB0RGVidWcuaXNMb2dFbmFibGVkKCkpIHtcbiAgICAgICAgICBOYXRpdmVTY3JpcHREZWJ1Zy5saXN0Vmlld0Vycm9yKGBUZW1wbGF0ZSBmb3Iga2V5ICcke3RlbXBsYXRlS2V5fScgbm90IGZvdW5kLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFyZ3MudmlldyA9IHRlbXBsYXRlLmNyZWF0ZSh7IGluZGV4LCBkYXRhOiBjdXJyZW50SXRlbSB9KTtcbiAgICB9XG4gICAgdGhpcy5zZXR1cFZpZXdSZWYodGVtcGxhdGUuZ2V0RW1iZWRkZWRWaWV3UmVmKGFyZ3MudmlldyksIGN1cnJlbnRJdGVtLCBpbmRleCwgYXJncy52aWV3KTtcblxuICAgIHRlbXBsYXRlLmF0dGFjaChhcmdzLnZpZXcpO1xuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXR1cFZpZXdSZWYodmlld1JlZjogRW1iZWRkZWRWaWV3UmVmPEl0ZW1Db250ZXh0PFQ+PiwgZGF0YTogVCwgaW5kZXg6IG51bWJlciwgbmF0aXZlRWxlbWVudDogVmlldyk6IHZvaWQge1xuICAgIGNvbnN0IGNvbnRleHQgPSB2aWV3UmVmLmNvbnRleHQ7XG4gICAgdGhpcy5zZXR1cEl0ZW1WaWV3Lm5leHQoeyB2aWV3OiB2aWV3UmVmLCBuYXRpdmVFbGVtZW50LCBkYXRhOiBkYXRhLCBpbmRleDogaW5kZXgsIGNvbnRleHQ6IGNvbnRleHQgfSk7XG4gIH1cblxuICBuZ0RvQ2hlY2soKSB7XG4gICAgaWYgKHRoaXMuX2RpZmZlcikge1xuICAgICAgaWYgKE5hdGl2ZVNjcmlwdERlYnVnLmlzTG9nRW5hYmxlZCgpKSB7XG4gICAgICAgIE5hdGl2ZVNjcmlwdERlYnVnLmxpc3RWaWV3TG9nKCduZ0RvQ2hlY2soKSAtIGV4ZWN1dGUgZGlmZmVyJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLl9kaWZmZXIuZGlmZih0aGlzLl9pdGVtcyBhcyBUW10pO1xuICAgICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKE5hdGl2ZVNjcmlwdERlYnVnLmlzTG9nRW5hYmxlZCgpKSB7XG4gICAgICAgICAgTmF0aXZlU2NyaXB0RGVidWcubGlzdFZpZXdMb2coJ25nRG9DaGVjaygpIC0gcmVmcmVzaCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50ZW1wbGF0ZWRJdGVtc1ZpZXcucmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgdHlwZSBSb290TG9jYXRvciA9IChub2RlczogQXJyYXk8dW5rbm93bj4sIG5lc3RMZXZlbDogbnVtYmVyKSA9PiBWaWV3O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SXRlbVZpZXdSb290KHZpZXdSZWY6IEVtYmVkZGVkVmlld1JlZjx1bmtub3duPiwgcm9vdExvY2F0b3I6IFJvb3RMb2NhdG9yID0gZXh0cmFjdFNpbmdsZVZpZXdSZWN1cnNpdmUpOiBWaWV3IHtcbiAgY29uc3Qgcm9vdFZpZXcgPSByb290TG9jYXRvcih2aWV3UmVmLnJvb3ROb2RlcywgMCk7XG4gIHJldHVybiByb290Vmlldztcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBhbmd1bGFyLWVzbGludC9kaXJlY3RpdmUtc2VsZWN0b3JcbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tuc1RlbXBsYXRlS2V5XSxbbnNUZW1wbGF0ZUtleXNdJyxcbiAgc3RhbmRhbG9uZTogdHJ1ZSxcbn0pXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVLZXlEaXJlY3RpdmU8VD4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxUPiwgQEhvc3QoKSBASW5qZWN0KFRFTVBMQVRFRF9JVEVNU19DT01QT05FTlQpIHByaXZhdGUgY29tcDogVGVtcGxhdGVkSXRlbXNIb3N0PFQ+KSB7fVxuXG4gIEBJbnB1dCgpXG4gIHNldCBuc1RlbXBsYXRlS2V5KHZhbHVlOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5jb21wICYmIHRoaXMudGVtcGxhdGVSZWYpIHtcbiAgICAgIHRoaXMuY29tcC5yZWdpc3RlclRlbXBsYXRlKHZhbHVlLCB0aGlzLnRlbXBsYXRlUmVmKTtcbiAgICB9XG4gIH1cbiAgQElucHV0KClcbiAgc2V0IG5zVGVtcGxhdGVLZXlzKHZhbHVlczogc3RyaW5nW10pIHtcbiAgICAvLyBzaW5nbGUgdGVtcGxhdGUgd2l0aCBtdWx0aXBsZSBrZXlzXG4gICAgaWYgKHRoaXMuY29tcCAmJiB0aGlzLnRlbXBsYXRlUmVmICYmIHZhbHVlcykge1xuICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlKSA9PiB0aGlzLmNvbXAucmVnaXN0ZXJUZW1wbGF0ZSh2YWx1ZSwgdGhpcy50ZW1wbGF0ZVJlZikpO1xuICAgIH1cbiAgfVxufVxuIl19