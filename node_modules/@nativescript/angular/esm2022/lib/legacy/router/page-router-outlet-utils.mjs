/**
 * There are cases where multiple activatedRoute nodes should be associated/handled by the same PageRouterOutlet.
 * We can gat additional ActivatedRoutes nodes when there is:
 *  - Lazy loading - there is an additional ActivatedRoute node for the RouteConfig with the `loadChildren` setup
 *  - Componentless routes - there is an additional ActivatedRoute node for the componentless RouteConfig
 *
 * Example:
 *   R  <-- root
 *   |
 * feature (lazy module) <-- RouteConfig: { path: "lazy", loadChildren: "./feature/feature.module#FeatureModule" }
 *   |
 * module (componentless route) <-- RouteConfig: { path: "module", children: [...] } // Note: No 'component'
 *   |
 *  home <-- RouteConfig: { path: "module", component: MyComponent } - this is what we get as activatedRoute param
 *
 *  In these cases we will mark the top-most node (feature). NSRouteReuseStrategy will detach the tree there and
 *  use this ActivateRoute as a kay for caching.
 */
export function findTopActivatedRouteNodeForOutlet(activatedRoute) {
    // TODO: test this and figure it out if it's really no longer needed
    return activatedRoute;
    // let outletActivatedRoute = activatedRoute;
    // while (outletActivatedRoute.parent && outletActivatedRoute.parent.routeConfig && !outletActivatedRoute.parent.routeConfig.component) {
    //   outletActivatedRoute = outletActivatedRoute.parent;
    // }
    // return outletActivatedRoute;
}
export const pageRouterActivatedSymbol = Symbol('page-router-activated');
export const loaderRefSymbol = Symbol('loader-ref');
export function destroyComponentRef(componentRef) {
    if (componentRef) {
        const loaderRef = componentRef[loaderRefSymbol];
        if (loaderRef) {
            loaderRef.destroy();
        }
        componentRef.destroy();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFnZS1yb3V0ZXItb3V0bGV0LXV0aWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvYW5ndWxhci9zcmMvbGliL2xlZ2FjeS9yb3V0ZXIvcGFnZS1yb3V0ZXItb3V0bGV0LXV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdBOzs7Ozs7Ozs7Ozs7Ozs7OztHQWlCRztBQUNILE1BQU0sVUFBVSxrQ0FBa0MsQ0FBQyxjQUFzQztJQUN2RixvRUFBb0U7SUFDcEUsT0FBTyxjQUFjLENBQUM7SUFDdEIsNkNBQTZDO0lBRTdDLHlJQUF5STtJQUN6SSx3REFBd0Q7SUFDeEQsSUFBSTtJQUVKLCtCQUErQjtBQUNqQyxDQUFDO0FBRUQsTUFBTSxDQUFDLE1BQU0seUJBQXlCLEdBQUcsTUFBTSxDQUFDLHVCQUF1QixDQUFDLENBQUM7QUFDekUsTUFBTSxDQUFDLE1BQU0sZUFBZSxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUVwRCxNQUFNLFVBQVUsbUJBQW1CLENBQUMsWUFBK0I7SUFDakUsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUNqQixNQUFNLFNBQVMsR0FBRyxZQUFZLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDaEQsSUFBSSxTQUFTLEVBQUUsQ0FBQztZQUNkLFNBQVMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUN0QixDQUFDO1FBQ0QsWUFBWSxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ3pCLENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBY3RpdmF0ZWRSb3V0ZSwgQWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgQ2hpbGRyZW5PdXRsZXRDb250ZXh0cywgUFJJTUFSWV9PVVRMRVQgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuXG4vKipcbiAqIFRoZXJlIGFyZSBjYXNlcyB3aGVyZSBtdWx0aXBsZSBhY3RpdmF0ZWRSb3V0ZSBub2RlcyBzaG91bGQgYmUgYXNzb2NpYXRlZC9oYW5kbGVkIGJ5IHRoZSBzYW1lIFBhZ2VSb3V0ZXJPdXRsZXQuXG4gKiBXZSBjYW4gZ2F0IGFkZGl0aW9uYWwgQWN0aXZhdGVkUm91dGVzIG5vZGVzIHdoZW4gdGhlcmUgaXM6XG4gKiAgLSBMYXp5IGxvYWRpbmcgLSB0aGVyZSBpcyBhbiBhZGRpdGlvbmFsIEFjdGl2YXRlZFJvdXRlIG5vZGUgZm9yIHRoZSBSb3V0ZUNvbmZpZyB3aXRoIHRoZSBgbG9hZENoaWxkcmVuYCBzZXR1cFxuICogIC0gQ29tcG9uZW50bGVzcyByb3V0ZXMgLSB0aGVyZSBpcyBhbiBhZGRpdGlvbmFsIEFjdGl2YXRlZFJvdXRlIG5vZGUgZm9yIHRoZSBjb21wb25lbnRsZXNzIFJvdXRlQ29uZmlnXG4gKlxuICogRXhhbXBsZTpcbiAqICAgUiAgPC0tIHJvb3RcbiAqICAgfFxuICogZmVhdHVyZSAobGF6eSBtb2R1bGUpIDwtLSBSb3V0ZUNvbmZpZzogeyBwYXRoOiBcImxhenlcIiwgbG9hZENoaWxkcmVuOiBcIi4vZmVhdHVyZS9mZWF0dXJlLm1vZHVsZSNGZWF0dXJlTW9kdWxlXCIgfVxuICogICB8XG4gKiBtb2R1bGUgKGNvbXBvbmVudGxlc3Mgcm91dGUpIDwtLSBSb3V0ZUNvbmZpZzogeyBwYXRoOiBcIm1vZHVsZVwiLCBjaGlsZHJlbjogWy4uLl0gfSAvLyBOb3RlOiBObyAnY29tcG9uZW50J1xuICogICB8XG4gKiAgaG9tZSA8LS0gUm91dGVDb25maWc6IHsgcGF0aDogXCJtb2R1bGVcIiwgY29tcG9uZW50OiBNeUNvbXBvbmVudCB9IC0gdGhpcyBpcyB3aGF0IHdlIGdldCBhcyBhY3RpdmF0ZWRSb3V0ZSBwYXJhbVxuICpcbiAqICBJbiB0aGVzZSBjYXNlcyB3ZSB3aWxsIG1hcmsgdGhlIHRvcC1tb3N0IG5vZGUgKGZlYXR1cmUpLiBOU1JvdXRlUmV1c2VTdHJhdGVneSB3aWxsIGRldGFjaCB0aGUgdHJlZSB0aGVyZSBhbmRcbiAqICB1c2UgdGhpcyBBY3RpdmF0ZVJvdXRlIGFzIGEga2F5IGZvciBjYWNoaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZFRvcEFjdGl2YXRlZFJvdXRlTm9kZUZvck91dGxldChhY3RpdmF0ZWRSb3V0ZTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCk6IEFjdGl2YXRlZFJvdXRlU25hcHNob3Qge1xuICAvLyBUT0RPOiB0ZXN0IHRoaXMgYW5kIGZpZ3VyZSBpdCBvdXQgaWYgaXQncyByZWFsbHkgbm8gbG9uZ2VyIG5lZWRlZFxuICByZXR1cm4gYWN0aXZhdGVkUm91dGU7XG4gIC8vIGxldCBvdXRsZXRBY3RpdmF0ZWRSb3V0ZSA9IGFjdGl2YXRlZFJvdXRlO1xuXG4gIC8vIHdoaWxlIChvdXRsZXRBY3RpdmF0ZWRSb3V0ZS5wYXJlbnQgJiYgb3V0bGV0QWN0aXZhdGVkUm91dGUucGFyZW50LnJvdXRlQ29uZmlnICYmICFvdXRsZXRBY3RpdmF0ZWRSb3V0ZS5wYXJlbnQucm91dGVDb25maWcuY29tcG9uZW50KSB7XG4gIC8vICAgb3V0bGV0QWN0aXZhdGVkUm91dGUgPSBvdXRsZXRBY3RpdmF0ZWRSb3V0ZS5wYXJlbnQ7XG4gIC8vIH1cblxuICAvLyByZXR1cm4gb3V0bGV0QWN0aXZhdGVkUm91dGU7XG59XG5cbmV4cG9ydCBjb25zdCBwYWdlUm91dGVyQWN0aXZhdGVkU3ltYm9sID0gU3ltYm9sKCdwYWdlLXJvdXRlci1hY3RpdmF0ZWQnKTtcbmV4cG9ydCBjb25zdCBsb2FkZXJSZWZTeW1ib2wgPSBTeW1ib2woJ2xvYWRlci1yZWYnKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lDb21wb25lbnRSZWYoY29tcG9uZW50UmVmOiBDb21wb25lbnRSZWY8YW55Pikge1xuICBpZiAoY29tcG9uZW50UmVmKSB7XG4gICAgY29uc3QgbG9hZGVyUmVmID0gY29tcG9uZW50UmVmW2xvYWRlclJlZlN5bWJvbF07XG4gICAgaWYgKGxvYWRlclJlZikge1xuICAgICAgbG9hZGVyUmVmLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgY29tcG9uZW50UmVmLmRlc3Ryb3koKTtcbiAgfVxufVxuIl19